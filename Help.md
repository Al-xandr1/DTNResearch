# Исходные данные
Исходные данные трасс можно взять тут: https://yadi.sk/d/qz5yuMo_vPsJM 
Это архивы с исходными трассами и результатами многоих экспериментов. Для распаковки может потребоваться несколько гигабайт на жёстком диске. Например, для KAIST:
* трассы лежат тут ./tracefiles (только файлы с расширением .txt)
* путевые точки, полученные WayPointFinder'ом - тут ./waypointfiles (KAIST Real Waypoints) (только файлы с расширением .wpt)
* файл bounds.bnd и прочие выходные файлы лежат в корне дистрибутива ./
* локации лежат, полученные через Hotspot - тут hotspotfiles
* и так далее. 


# Запуск WaypointFinder 
Запуск этой программы возможен в нескольких вариантах: 
* для определения путевых точек с последующим подсчётом статистики: 
	- для этого предварительно в модуле WaypointFinder нужно включить (раскомментировать) подпрограмму нахождения путевых точек:
		argc = 2; argv = new char*[2] {"program", WPFIND}; 
		mainMain(argc, argv);
	- положить известные файлы исходных трасс в папку tracefiles в директорию программы и запусить программу;
	- в результате в папке waypointfiles появятся путевые точки и файл статистики statistics.stat на основе путевых точек. 
* для подсчёта статистики на имеющихся путевых точках (или возможно сразу на точках трассы - если нужно, опишу позже): 
	- для этого предварительно в модуле WaypointFinder нужно выключить (закомментировать) подпрограмму нахождения путевых точек (см. строчки выше);
	- положить известные файлы путевых точек в папку waypointfiles в директорию программы и запусить программу. 
	- в результате в папке waypointfiles появится файл statistics.stat - статистика мобильности на основе путевых точек без предварительного вызова аггрегирующей функции WPFIND. 
* файл bound.bnd получается для трасс и путевых точек свои (в соответствующих папках)


# Запуск Hotspot
Для запуска процедуры определения локаций нужно:
* положить файлы с путевыми точками в папке waypointfiles в директорию программы; 
* положить файл bound.bnd (от путевых точек) в директорию программы; 
* запустить Hotspot
* в резульате получим в директории программы выходные файлы с локациями в папке hotspotfiles и файл locations.loc


# Импортирование проекта

После выкачивания проекта нужно импортировать все проекты в рабочую область (если их нет). Сейчас это RoutingTest2, SelfSimLATP, LevyHotSpotsLATP, RealMobility, SimpleLevy и только (там был ещё LevyHotSpotsRandom, который не стоит импортировать, открывать и делать от него зависимости - в нём ошибки)
 
Зависимости такие:
* все проекты зависят от inet
* RoutingTest2 зависит от SelfSimLATP, LevyHotSpotsLATP, RealMobility, SimpleLevy
* SelfSimLATP зависит от SimpleLevy
* LevyHotSpotsLATP зависит от SimpleLevy
* RealMobility зависит от SimpleLevy
 
Также нужно RoutingTest2 собрать как exe файл, а SelfSimLATP, LevyHotSpotsLATP, RealMobility, SimpleLevy как dll библиотеки (это тоже делается в настройках проекта.)
 
Сначала нужно импортировать все проекты в Workspace Omnet++. Для этого нужно:
1. импортировать все проекты отдельно (File -> Import -> Genral -> Existing projects into Workspace -> Select root directory)
2. зайти в настройки проекта модулей в радел ProjectPreferences и проставить зависимости на:
	* для SimpleLevy на inet
	* для SelfSimLATP на inet и SimpleLevy
	* для LevyHotSpotsLATP на inet и SimpleLevy
	* для LevyHotSpotsRandom на inet и SimpleLevy
	* для RoutingTest2 на на inet и SimpleLevy, SelfSimLATP, LevyHotSpotsLATP, LevyHotSpotsRandom
3. и помнить, что все зависимости должны быть собраны НЕ в exe, а в dll. Т.е. если запускаем RoutingTest2, то нужно проекты SimpleLevy, SelfSimLATP, LevyHotSpotsLATP, LevyHotSpotsRando собрать как dll. Если запускаем SelfSimLATP, то нужно проект SimpleLevy собрать как dll. Делается это в Настройки проекта -> Omnet++ -> Makefile -> вкладка Target -> поставить галочку Shared Library. Тогда при компиляции родительские проекты будет видеть компилятор.
 

# Эксперименты (DRAFT)

Чтобы начать проводить эксперименты нужно взять ветку experiments. Сейчас там есть две ветки master и experiments. Ветка с профетом уже смёржена в ветку master, а оттуда в experiments.
 
Таким образом, в master у нас актуальный код со всеми включёнными проверками: if(...) exit(-...) или ASSERT. Это нужно для того, чтобы в мастере код как можно "быстрее и чувствительнее" реагировал на изменения и выкидывал ошибки, чтобы их можно было быстрее обнаруживать и исправлять. Однако это несёт дополнительную нагрузку из-за большого числа проверок. Поэтому для проведения экспериментов я сделал отдельную ветку expreriments, где всё тоже самое, только закомментированы все отладочные проверки (или большинство проверок - другие мог оставить, так как они не влияли на производительность).
Поэтому, на всякий случай, если Вы захотите что-нибудь доработать - то это, конечно, можно делать в periments (как говориться, не отходя от кассы), но коммитить нужно в мастер, а оттуда потом делать мёрж в experiments. Да и проверять код лучше в мастере - там много проверок.
 
Когда будете делать git pull в ветке experiments, могут быть конфликты обновления (если у вас такая ветка уже есть, она старая и там что-то менялось) - тогда нужно каждый файл отдельно поправить - но это лучше отдельно расскажу, если случится.
 
После того, как build проекта RoutingTest2 прошёл нормально, можно проводить запуск. Для этого нужно:
1. в папке проекта RoutingTest2 нужно создать папку Traces и поместить туда всё о трассе KAIST (или любой другой), а именно: hotspotfiles, rootfiles, tracefiles, waypointfiles, allroots.roo, bounds.bnd, herst.txt, length.hst, locations.loc, spotcount.cnt. Все эти данные есть тут: https://yadi.sk/d/qz5yuMo_vPsJM 
2. также нужно заранее создать в RoutingTest2 папку outTrace - туда будут генерироваться все выходные файлы.
3. Теперь можно запускать модель RoutingTest2 с конфигурацией RegularRootLATP для запуска маршрутизации. Параметры ciP и aliP меняются в omnetpp.ini файле. То, как нужно было проверить записал тут: https://github.com/Al-xandr1/DTNResearch/issues/57 
 
После окончания моделирования в папке out появляется файл routeHistory.xml - это файл с длительностью маршрутов узлов по дням (матрица, фактически). Чтобы посчитать среднее квадратическое отклонение этой матрицы от матрицы эталонных длительностей нужно:
1. раскомментировать строчку calculator: StatisticsCalculator; в файле StatisticsCollectorNetwork.ned - это калькулятор СКО, его код в StatisticsCalculator.h и StatisticsCalculator.cpp - там в комментариях описана как выглядит матрица.
2. в папку out положить файл routeHistory_KAIST_origin.xml, который нужно переименовать в routeHistory_another.xml - тут будет лежать длительность первых дней всех пользователей с территории KAIST - и тут это фактически будет вектор. (Возможность расчёта для матрицы заложил на всякий случай)
3. в итоге получаем в папке out два файла routeHistory.xml (от только что прошедшего моделирования) и routeHistory_another.xml
4. теперь запускаем модель с конфигурацией StatisticsCollector в консоли видим значение СКО. В общем случае там считается для матрици, где в столбцах лежат длительности всех узлов, соответственно получается что значения СКО считаются для всех столбцов. В случае сравнения в одним первым днём -> это один столбец -> одно значение.
Там есть проверка на то, что размеры матриц одной и другой должны быть равно. Если это не так - будет ошибка.
 
Так же не забудьте, что если меняете число пользователей, то оно должно быть одинаково в файлах routeHistory.xml и routeHistory_another.xml, т.е. в routeHistory_another.xml стоит предварительно от общего числа (92 пользователя) отрезать столько сколько нужно
 


# Запуск SLAW модели НА ОСНОВЕ ДАННЫХ Levy модели:
1. Запустить Levy модель для получения папок с данными waypointfiles, hotspotfiles, tracefiles (для прогонки через WaypointFinder если нужно для получения файл statistics.stat), locations.loc;
2. Запустиь RootFinder на основе выше упомянутых папок waypointfiles и hotspotfiles. Получить папку rootfiles, length.hst, allroots.roo;
3. Чтобы получить файл bounds.bnd нужно запустить модуль WaypointFinder на основе полученных ранее waypointfiles. 
	Для этого предварительно в модуле WaypointFinder нужно отключить подпрограмму нахождения путевых точек, закомментировав строчку: argc = 2; argv = new char*[2] {"program", WPFIND}; mainMain(argc, argv);
	Также после вызова этого модуля получается файл statistics.stat - статистика мобильности на основе ПУТЕВЫХ точек без предварительного вызова аггрегирующей функции WPFIND. 
	Если нужно предварительно прогнать аггрегирующую процедуру - то нужно раскомментировать строчку: argc = 2; argv = new char*[2] {"program", WPFIND}; mainMain(argc, argv);
4. Далее нужно получить файл spotcount.cnt с помощью модуля RepeatCounter. Входные данные для него hotspotfiles и rootfiles;
5. Файлы herst.txt и variances.txt нужно взять на основе данных от реальной трассы
6. Полученный набор файлов положить в ..\DTNResearch\RoutingResearch\RoutingTest2\Traces\